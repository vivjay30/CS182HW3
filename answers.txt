Comparison of results from Parts 3-5:

Running the DFS without any heuristics gives 56734 nodes explored at a time of 10.6 seconds. Running it with the "on the fly" forward checking gives 7095 nodes explored at a time of 10.7 seconds. It is interesting that this actualy takes more time, however the overhead comes from the fact that for each forward check, we are doing checking the domain of 81 variables, requiring checking 27 spots for each variable. A more dynamic forward checking would definitely reduce this speed.

Running most constrained function explored 787 nodes at a time of 1.0 seconds. This reduction makes sense since we are more directly approaching the goal state. Running it with forward checking explored 734 nodes at 1.8 seconds. As expected the nodes explored are fewer, however it is not as big a reduction as you might think. This shows that following the most constrained variable rarely leads to inconsistent branches since the variable about to become inconsistent would be explored first. 

Part 9:
To solve Sudoku using Genetic Algorithms, we would first create a vector of random complete but inconsistent solutions. Each chromosome stores information as an initial solution string: a random assignment of numbers from 1 to 9 are placed in each row that ensures that we have a random grid which is partially consistent. For the fitness function, we can count the number of duplicates in each column/box, and the lower the number of duplicates, the higher is the fitness function for that column/box. The population of solution strings are ranked according to the fitness function, and few solutions are probabilistically selected and retained. Then we randomly select two solution strings and choose a crossover point. We then apply the mutator function to the string, until we come up with a new population. We design the mutator function by randomly flipping solution bits. And crossover operator is designed by concatenating the first part of the first string with the last part of the second string. If we reach the local minima, and canâ€™t come up with a new population, we repeat the process by randomly selecting and retaining new solutions.